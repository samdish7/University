# Lab 6 COSC 220; Sam Disharoon

*README written in 2023* :grinning:

## Overview

This program demonstrates different sorting algorithm times. This was the introduction to the *Big O* notation. The three sorting algorithms shown are:
1. Insertion Sort
2. Bubble Sort
3. Selection Sort

The table below shows the theoretical time complexities of each:

| |Bubble|Selection|Insertion|
|-|------|---------|---------|
|Small|Best: O(5), Worst: O(5<sup>2</sup>)|Best: O(5<sup>2</sup>), Worst: O(5<sup>2</sup>)|Best: O(5), Worst: O(5<sup>2</sup>)|
|Meduium|Best: O(100), Worst: O(100<sup>2</sup>)|Best: O(100<sup>2</sup>), Worst: O(100<sup>2</sup>)|Best: O(100), Worst: O(100<sup>2</sup>)|
|Large|Best: O(10000), Worst: O(10000<sup>2</sup>)|Best: O(10000<sup>2</sup>), Worst: O(10000<sup>2</sup>)|Best: O(10000), Worst: O(10000<sup>2</sup>)|

The sizes are as follows:
- Small = 5
- Medium = 100
- Large = 10000

The rest of the report is structured as:

`2.)	The timing increases as the number of elements increases, the size doesn't matter because ints take up the same amount of memory regardless.  Just because you double the size of the array, doesn't mean you will have a time four times larger, it all depends on the elements in the array.

3.)	On spreadsheet

4.)	Best case for each of the sorts was the smallest one. Bubble performed the worst of them all, however, selection seemed to be best with larger arrays that are worst case.`

These appear to answer various lab questions, but I do not have access to the questions. Plus, the *spreadsheet* referenced is just the times that the program outputs, therefore I won't bother with displaying them here. 

## Feedback

Again, difficult to read because of the lack of formatting, but the program works like a charm and does not leak. Would like to not have an explanation of what it is doing throughout the program but overall good work.

***Overall Rating: 9/10**
